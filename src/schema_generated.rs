// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TAG: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TAG: i8 = 113;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TAG: [Tag; 114] = [
  Tag::un,
  Tag::adj,
  Tag::adv,
  Tag::art,
  Tag::conj,
  Tag::intj,
  Tag::n,
  Tag::part,
  Tag::pref,
  Tag::prep,
  Tag::postp,
  Tag::pron,
  Tag::suff,
  Tag::v,
  Tag::abv,
  Tag::adf,
  Tag::aff,
  Tag::aux_adj,
  Tag::aux_v,
  Tag::aux,
  Tag::chr,
  Tag::conj_c,
  Tag::conj_s,
  Tag::cop,
  Tag::cf,
  Tag::ctr,
  Tag::det,
  Tag::expr,
  Tag::inf,
  Tag::intf,
  Tag::name,
  Tag::num,
  Tag::phr_adv,
  Tag::phr_adj,
  Tag::phr_prep,
  Tag::phr,
  Tag::propn,
  Tag::prov,
  Tag::punc,
  Tag::sym,
  Tag::vi,
  Tag::vt,
  Tag::adj_f,
  Tag::adj_ix,
  Tag::adj_kari,
  Tag::adj_ku,
  Tag::adj_na,
  Tag::adj_nari,
  Tag::adj_no,
  Tag::adj_pn,
  Tag::adj_shiku,
  Tag::adj_t,
  Tag::adv_to,
  Tag::n_adv,
  Tag::n_pref,
  Tag::n_suf,
  Tag::n_t,
  Tag::v_unspec,
  Tag::v1_s,
  Tag::v1,
  Tag::v2a_s,
  Tag::v2b_k,
  Tag::v2b_s,
  Tag::v2d_k,
  Tag::v2d_s,
  Tag::v2g_k,
  Tag::v2g_s,
  Tag::v2h_k,
  Tag::v2h_s,
  Tag::v2k_k,
  Tag::v2k_s,
  Tag::v2m_k,
  Tag::v2m_s,
  Tag::v2n_s,
  Tag::v2r_k,
  Tag::v2r_s,
  Tag::v2s_s,
  Tag::v2t_k,
  Tag::v2t_s,
  Tag::v2w_s,
  Tag::v2y_k,
  Tag::v2y_s,
  Tag::v2z_s,
  Tag::v4b,
  Tag::v4g,
  Tag::v4h,
  Tag::v4k,
  Tag::v4m,
  Tag::v4n,
  Tag::v4r,
  Tag::v4s,
  Tag::v4t,
  Tag::v5aru,
  Tag::v5b,
  Tag::v5g,
  Tag::v5k_s,
  Tag::v5k,
  Tag::v5m,
  Tag::v5n,
  Tag::v5r_i,
  Tag::v5r,
  Tag::v5s,
  Tag::v5t,
  Tag::v5u_s,
  Tag::v5u,
  Tag::v5uru,
  Tag::vk,
  Tag::vn,
  Tag::vr,
  Tag::vs_c,
  Tag::vs_i,
  Tag::vs_s,
  Tag::vs,
  Tag::vz,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Tag(pub i8);
#[allow(non_upper_case_globals)]
impl Tag {
  pub const un: Self = Self(0);
  pub const adj: Self = Self(1);
  pub const adv: Self = Self(2);
  pub const art: Self = Self(3);
  pub const conj: Self = Self(4);
  pub const intj: Self = Self(5);
  pub const n: Self = Self(6);
  pub const part: Self = Self(7);
  pub const pref: Self = Self(8);
  pub const prep: Self = Self(9);
  pub const postp: Self = Self(10);
  pub const pron: Self = Self(11);
  pub const suff: Self = Self(12);
  pub const v: Self = Self(13);
  pub const abv: Self = Self(14);
  pub const adf: Self = Self(15);
  pub const aff: Self = Self(16);
  pub const aux_adj: Self = Self(17);
  pub const aux_v: Self = Self(18);
  pub const aux: Self = Self(19);
  pub const chr: Self = Self(20);
  pub const conj_c: Self = Self(21);
  pub const conj_s: Self = Self(22);
  pub const cop: Self = Self(23);
  pub const cf: Self = Self(24);
  pub const ctr: Self = Self(25);
  pub const det: Self = Self(26);
  pub const expr: Self = Self(27);
  pub const inf: Self = Self(28);
  pub const intf: Self = Self(29);
  pub const name: Self = Self(30);
  pub const num: Self = Self(31);
  pub const phr_adv: Self = Self(32);
  pub const phr_adj: Self = Self(33);
  pub const phr_prep: Self = Self(34);
  pub const phr: Self = Self(35);
  pub const propn: Self = Self(36);
  pub const prov: Self = Self(37);
  pub const punc: Self = Self(38);
  pub const sym: Self = Self(39);
  pub const vi: Self = Self(40);
  pub const vt: Self = Self(41);
  pub const adj_f: Self = Self(42);
  pub const adj_ix: Self = Self(43);
  pub const adj_kari: Self = Self(44);
  pub const adj_ku: Self = Self(45);
  pub const adj_na: Self = Self(46);
  pub const adj_nari: Self = Self(47);
  pub const adj_no: Self = Self(48);
  pub const adj_pn: Self = Self(49);
  pub const adj_shiku: Self = Self(50);
  pub const adj_t: Self = Self(51);
  pub const adv_to: Self = Self(52);
  pub const n_adv: Self = Self(53);
  pub const n_pref: Self = Self(54);
  pub const n_suf: Self = Self(55);
  pub const n_t: Self = Self(56);
  pub const v_unspec: Self = Self(57);
  pub const v1_s: Self = Self(58);
  pub const v1: Self = Self(59);
  pub const v2a_s: Self = Self(60);
  pub const v2b_k: Self = Self(61);
  pub const v2b_s: Self = Self(62);
  pub const v2d_k: Self = Self(63);
  pub const v2d_s: Self = Self(64);
  pub const v2g_k: Self = Self(65);
  pub const v2g_s: Self = Self(66);
  pub const v2h_k: Self = Self(67);
  pub const v2h_s: Self = Self(68);
  pub const v2k_k: Self = Self(69);
  pub const v2k_s: Self = Self(70);
  pub const v2m_k: Self = Self(71);
  pub const v2m_s: Self = Self(72);
  pub const v2n_s: Self = Self(73);
  pub const v2r_k: Self = Self(74);
  pub const v2r_s: Self = Self(75);
  pub const v2s_s: Self = Self(76);
  pub const v2t_k: Self = Self(77);
  pub const v2t_s: Self = Self(78);
  pub const v2w_s: Self = Self(79);
  pub const v2y_k: Self = Self(80);
  pub const v2y_s: Self = Self(81);
  pub const v2z_s: Self = Self(82);
  pub const v4b: Self = Self(83);
  pub const v4g: Self = Self(84);
  pub const v4h: Self = Self(85);
  pub const v4k: Self = Self(86);
  pub const v4m: Self = Self(87);
  pub const v4n: Self = Self(88);
  pub const v4r: Self = Self(89);
  pub const v4s: Self = Self(90);
  pub const v4t: Self = Self(91);
  pub const v5aru: Self = Self(92);
  pub const v5b: Self = Self(93);
  pub const v5g: Self = Self(94);
  pub const v5k_s: Self = Self(95);
  pub const v5k: Self = Self(96);
  pub const v5m: Self = Self(97);
  pub const v5n: Self = Self(98);
  pub const v5r_i: Self = Self(99);
  pub const v5r: Self = Self(100);
  pub const v5s: Self = Self(101);
  pub const v5t: Self = Self(102);
  pub const v5u_s: Self = Self(103);
  pub const v5u: Self = Self(104);
  pub const v5uru: Self = Self(105);
  pub const vk: Self = Self(106);
  pub const vn: Self = Self(107);
  pub const vr: Self = Self(108);
  pub const vs_c: Self = Self(109);
  pub const vs_i: Self = Self(110);
  pub const vs_s: Self = Self(111);
  pub const vs: Self = Self(112);
  pub const vz: Self = Self(113);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 113;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::un,
    Self::adj,
    Self::adv,
    Self::art,
    Self::conj,
    Self::intj,
    Self::n,
    Self::part,
    Self::pref,
    Self::prep,
    Self::postp,
    Self::pron,
    Self::suff,
    Self::v,
    Self::abv,
    Self::adf,
    Self::aff,
    Self::aux_adj,
    Self::aux_v,
    Self::aux,
    Self::chr,
    Self::conj_c,
    Self::conj_s,
    Self::cop,
    Self::cf,
    Self::ctr,
    Self::det,
    Self::expr,
    Self::inf,
    Self::intf,
    Self::name,
    Self::num,
    Self::phr_adv,
    Self::phr_adj,
    Self::phr_prep,
    Self::phr,
    Self::propn,
    Self::prov,
    Self::punc,
    Self::sym,
    Self::vi,
    Self::vt,
    Self::adj_f,
    Self::adj_ix,
    Self::adj_kari,
    Self::adj_ku,
    Self::adj_na,
    Self::adj_nari,
    Self::adj_no,
    Self::adj_pn,
    Self::adj_shiku,
    Self::adj_t,
    Self::adv_to,
    Self::n_adv,
    Self::n_pref,
    Self::n_suf,
    Self::n_t,
    Self::v_unspec,
    Self::v1_s,
    Self::v1,
    Self::v2a_s,
    Self::v2b_k,
    Self::v2b_s,
    Self::v2d_k,
    Self::v2d_s,
    Self::v2g_k,
    Self::v2g_s,
    Self::v2h_k,
    Self::v2h_s,
    Self::v2k_k,
    Self::v2k_s,
    Self::v2m_k,
    Self::v2m_s,
    Self::v2n_s,
    Self::v2r_k,
    Self::v2r_s,
    Self::v2s_s,
    Self::v2t_k,
    Self::v2t_s,
    Self::v2w_s,
    Self::v2y_k,
    Self::v2y_s,
    Self::v2z_s,
    Self::v4b,
    Self::v4g,
    Self::v4h,
    Self::v4k,
    Self::v4m,
    Self::v4n,
    Self::v4r,
    Self::v4s,
    Self::v4t,
    Self::v5aru,
    Self::v5b,
    Self::v5g,
    Self::v5k_s,
    Self::v5k,
    Self::v5m,
    Self::v5n,
    Self::v5r_i,
    Self::v5r,
    Self::v5s,
    Self::v5t,
    Self::v5u_s,
    Self::v5u,
    Self::v5uru,
    Self::vk,
    Self::vn,
    Self::vr,
    Self::vs_c,
    Self::vs_i,
    Self::vs_s,
    Self::vs,
    Self::vz,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::un => Some("un"),
      Self::adj => Some("adj"),
      Self::adv => Some("adv"),
      Self::art => Some("art"),
      Self::conj => Some("conj"),
      Self::intj => Some("intj"),
      Self::n => Some("n"),
      Self::part => Some("part"),
      Self::pref => Some("pref"),
      Self::prep => Some("prep"),
      Self::postp => Some("postp"),
      Self::pron => Some("pron"),
      Self::suff => Some("suff"),
      Self::v => Some("v"),
      Self::abv => Some("abv"),
      Self::adf => Some("adf"),
      Self::aff => Some("aff"),
      Self::aux_adj => Some("aux_adj"),
      Self::aux_v => Some("aux_v"),
      Self::aux => Some("aux"),
      Self::chr => Some("chr"),
      Self::conj_c => Some("conj_c"),
      Self::conj_s => Some("conj_s"),
      Self::cop => Some("cop"),
      Self::cf => Some("cf"),
      Self::ctr => Some("ctr"),
      Self::det => Some("det"),
      Self::expr => Some("expr"),
      Self::inf => Some("inf"),
      Self::intf => Some("intf"),
      Self::name => Some("name"),
      Self::num => Some("num"),
      Self::phr_adv => Some("phr_adv"),
      Self::phr_adj => Some("phr_adj"),
      Self::phr_prep => Some("phr_prep"),
      Self::phr => Some("phr"),
      Self::propn => Some("propn"),
      Self::prov => Some("prov"),
      Self::punc => Some("punc"),
      Self::sym => Some("sym"),
      Self::vi => Some("vi"),
      Self::vt => Some("vt"),
      Self::adj_f => Some("adj_f"),
      Self::adj_ix => Some("adj_ix"),
      Self::adj_kari => Some("adj_kari"),
      Self::adj_ku => Some("adj_ku"),
      Self::adj_na => Some("adj_na"),
      Self::adj_nari => Some("adj_nari"),
      Self::adj_no => Some("adj_no"),
      Self::adj_pn => Some("adj_pn"),
      Self::adj_shiku => Some("adj_shiku"),
      Self::adj_t => Some("adj_t"),
      Self::adv_to => Some("adv_to"),
      Self::n_adv => Some("n_adv"),
      Self::n_pref => Some("n_pref"),
      Self::n_suf => Some("n_suf"),
      Self::n_t => Some("n_t"),
      Self::v_unspec => Some("v_unspec"),
      Self::v1_s => Some("v1_s"),
      Self::v1 => Some("v1"),
      Self::v2a_s => Some("v2a_s"),
      Self::v2b_k => Some("v2b_k"),
      Self::v2b_s => Some("v2b_s"),
      Self::v2d_k => Some("v2d_k"),
      Self::v2d_s => Some("v2d_s"),
      Self::v2g_k => Some("v2g_k"),
      Self::v2g_s => Some("v2g_s"),
      Self::v2h_k => Some("v2h_k"),
      Self::v2h_s => Some("v2h_s"),
      Self::v2k_k => Some("v2k_k"),
      Self::v2k_s => Some("v2k_s"),
      Self::v2m_k => Some("v2m_k"),
      Self::v2m_s => Some("v2m_s"),
      Self::v2n_s => Some("v2n_s"),
      Self::v2r_k => Some("v2r_k"),
      Self::v2r_s => Some("v2r_s"),
      Self::v2s_s => Some("v2s_s"),
      Self::v2t_k => Some("v2t_k"),
      Self::v2t_s => Some("v2t_s"),
      Self::v2w_s => Some("v2w_s"),
      Self::v2y_k => Some("v2y_k"),
      Self::v2y_s => Some("v2y_s"),
      Self::v2z_s => Some("v2z_s"),
      Self::v4b => Some("v4b"),
      Self::v4g => Some("v4g"),
      Self::v4h => Some("v4h"),
      Self::v4k => Some("v4k"),
      Self::v4m => Some("v4m"),
      Self::v4n => Some("v4n"),
      Self::v4r => Some("v4r"),
      Self::v4s => Some("v4s"),
      Self::v4t => Some("v4t"),
      Self::v5aru => Some("v5aru"),
      Self::v5b => Some("v5b"),
      Self::v5g => Some("v5g"),
      Self::v5k_s => Some("v5k_s"),
      Self::v5k => Some("v5k"),
      Self::v5m => Some("v5m"),
      Self::v5n => Some("v5n"),
      Self::v5r_i => Some("v5r_i"),
      Self::v5r => Some("v5r"),
      Self::v5s => Some("v5s"),
      Self::v5t => Some("v5t"),
      Self::v5u_s => Some("v5u_s"),
      Self::v5u => Some("v5u"),
      Self::v5uru => Some("v5uru"),
      Self::vk => Some("vk"),
      Self::vn => Some("vn"),
      Self::vr => Some("vr"),
      Self::vs_c => Some("vs_c"),
      Self::vs_i => Some("vs_i"),
      Self::vs_s => Some("vs_s"),
      Self::vs => Some("vs"),
      Self::vz => Some("vz"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Tag {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Tag {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Tag {
    type Output = Tag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Tag {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Tag {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Tag {}
pub enum ExampleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Example<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Example<'a> {
  type Inner = Example<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Example<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_TRANSLATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Example { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ExampleArgs<'args>
  ) -> flatbuffers::WIPOffset<Example<'bldr>> {
    let mut builder = ExampleBuilder::new(_fbb);
    if let Some(x) = args.translation { builder.add_translation(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Example::VT_VALUE, None)}
  }
  #[inline]
  pub fn translation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Example::VT_TRANSLATION, None)}
  }
}

impl flatbuffers::Verifiable for Example<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("translation", Self::VT_TRANSLATION, false)?
     .finish();
    Ok(())
  }
}
pub struct ExampleArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub translation: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExampleArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExampleArgs {
      value: None,
      translation: None,
    }
  }
}

pub struct ExampleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExampleBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Example::VT_VALUE, value);
  }
  #[inline]
  pub fn add_translation(&mut self, translation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Example::VT_TRANSLATION, translation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExampleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExampleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Example<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Example<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Example");
      ds.field("value", &self.value());
      ds.field("translation", &self.translation());
      ds.finish()
  }
}
pub enum DefinitionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Definition<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Definition<'a> {
  type Inner = Definition<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Definition<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_SEE: flatbuffers::VOffsetT = 6;
  pub const VT_EXAMPLES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Definition { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DefinitionArgs<'args>
  ) -> flatbuffers::WIPOffset<Definition<'bldr>> {
    let mut builder = DefinitionBuilder::new(_fbb);
    if let Some(x) = args.examples { builder.add_examples(x); }
    if let Some(x) = args.see { builder.add_see(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Definition::VT_VALUE, None)}
  }
  #[inline]
  pub fn see(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Definition::VT_SEE, None)}
  }
  #[inline]
  pub fn examples(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Example<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Example>>>>(Definition::VT_EXAMPLES, None)}
  }
}

impl flatbuffers::Verifiable for Definition<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("see", Self::VT_SEE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Example>>>>("examples", Self::VT_EXAMPLES, false)?
     .finish();
    Ok(())
  }
}
pub struct DefinitionArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub see: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub examples: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Example<'a>>>>>,
}
impl<'a> Default for DefinitionArgs<'a> {
  #[inline]
  fn default() -> Self {
    DefinitionArgs {
      value: None,
      see: None,
      examples: None,
    }
  }
}

pub struct DefinitionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DefinitionBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Definition::VT_VALUE, value);
  }
  #[inline]
  pub fn add_see(&mut self, see: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Definition::VT_SEE, see);
  }
  #[inline]
  pub fn add_examples(&mut self, examples: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Example<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Definition::VT_EXAMPLES, examples);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DefinitionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DefinitionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Definition<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Definition<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Definition");
      ds.field("value", &self.value());
      ds.field("see", &self.see());
      ds.field("examples", &self.examples());
      ds.finish()
  }
}
pub enum UsageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Usage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Usage<'a> {
  type Inner = Usage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Usage<'a> {
  pub const VT_TAGS: flatbuffers::VOffsetT = 4;
  pub const VT_PITCHES: flatbuffers::VOffsetT = 6;
  pub const VT_DEFINITIONS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Usage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UsageArgs<'args>
  ) -> flatbuffers::WIPOffset<Usage<'bldr>> {
    let mut builder = UsageBuilder::new(_fbb);
    if let Some(x) = args.definitions { builder.add_definitions(x); }
    if let Some(x) = args.pitches { builder.add_pitches(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    builder.finish()
  }


  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, Tag>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Tag>>>(Usage::VT_TAGS, None)}
  }
  #[inline]
  pub fn pitches(&self) -> Option<flatbuffers::Vector<'a, i16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i16>>>(Usage::VT_PITCHES, None)}
  }
  #[inline]
  pub fn definitions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Definition<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Definition>>>>(Usage::VT_DEFINITIONS, None)}
  }
}

impl flatbuffers::Verifiable for Usage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Tag>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i16>>>("pitches", Self::VT_PITCHES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Definition>>>>("definitions", Self::VT_DEFINITIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct UsageArgs<'a> {
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Tag>>>,
    pub pitches: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i16>>>,
    pub definitions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Definition<'a>>>>>,
}
impl<'a> Default for UsageArgs<'a> {
  #[inline]
  fn default() -> Self {
    UsageArgs {
      tags: None,
      pitches: None,
      definitions: None,
    }
  }
}

pub struct UsageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UsageBuilder<'a, 'b> {
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Tag>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Usage::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_pitches(&mut self, pitches: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Usage::VT_PITCHES, pitches);
  }
  #[inline]
  pub fn add_definitions(&mut self, definitions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Definition<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Usage::VT_DEFINITIONS, definitions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UsageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UsageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Usage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Usage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Usage");
      ds.field("tags", &self.tags());
      ds.field("pitches", &self.pitches());
      ds.field("definitions", &self.definitions());
      ds.finish()
  }
}
pub enum EntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Entry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Entry<'a> {
  type Inner = Entry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Entry<'a> {
  pub const VT_TERM: flatbuffers::VOffsetT = 4;
  pub const VT_READING: flatbuffers::VOffsetT = 6;
  pub const VT_SEE: flatbuffers::VOffsetT = 8;
  pub const VT_ALT: flatbuffers::VOffsetT = 10;
  pub const VT_FREQUENCIES: flatbuffers::VOffsetT = 12;
  pub const VT_USAGES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Entry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EntryArgs<'args>
  ) -> flatbuffers::WIPOffset<Entry<'bldr>> {
    let mut builder = EntryBuilder::new(_fbb);
    if let Some(x) = args.usages { builder.add_usages(x); }
    if let Some(x) = args.frequencies { builder.add_frequencies(x); }
    if let Some(x) = args.alt { builder.add_alt(x); }
    if let Some(x) = args.see { builder.add_see(x); }
    if let Some(x) = args.reading { builder.add_reading(x); }
    if let Some(x) = args.term { builder.add_term(x); }
    builder.finish()
  }


  #[inline]
  pub fn term(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entry::VT_TERM, None)}
  }
  #[inline]
  pub fn reading(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entry::VT_READING, None)}
  }
  #[inline]
  pub fn see(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Entry::VT_SEE, None)}
  }
  #[inline]
  pub fn alt(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Entry::VT_ALT, None)}
  }
  #[inline]
  pub fn frequencies(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(Entry::VT_FREQUENCIES, None)}
  }
  #[inline]
  pub fn usages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Usage<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Usage>>>>(Entry::VT_USAGES, None)}
  }
}

impl flatbuffers::Verifiable for Entry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("term", Self::VT_TERM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reading", Self::VT_READING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("see", Self::VT_SEE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("alt", Self::VT_ALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("frequencies", Self::VT_FREQUENCIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Usage>>>>("usages", Self::VT_USAGES, false)?
     .finish();
    Ok(())
  }
}
pub struct EntryArgs<'a> {
    pub term: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reading: Option<flatbuffers::WIPOffset<&'a str>>,
    pub see: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub alt: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub frequencies: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub usages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Usage<'a>>>>>,
}
impl<'a> Default for EntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    EntryArgs {
      term: None,
      reading: None,
      see: None,
      alt: None,
      frequencies: None,
      usages: None,
    }
  }
}

pub struct EntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_term(&mut self, term: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entry::VT_TERM, term);
  }
  #[inline]
  pub fn add_reading(&mut self, reading: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entry::VT_READING, reading);
  }
  #[inline]
  pub fn add_see(&mut self, see: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entry::VT_SEE, see);
  }
  #[inline]
  pub fn add_alt(&mut self, alt: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entry::VT_ALT, alt);
  }
  #[inline]
  pub fn add_frequencies(&mut self, frequencies: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entry::VT_FREQUENCIES, frequencies);
  }
  #[inline]
  pub fn add_usages(&mut self, usages: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Usage<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entry::VT_USAGES, usages);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Entry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Entry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Entry");
      ds.field("term", &self.term());
      ds.field("reading", &self.reading());
      ds.field("see", &self.see());
      ds.field("alt", &self.alt());
      ds.field("frequencies", &self.frequencies());
      ds.field("usages", &self.usages());
      ds.finish()
  }
}
pub enum DictionaryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Dictionary<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Dictionary<'a> {
  type Inner = Dictionary<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Dictionary<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_ENTRIES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Dictionary { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DictionaryArgs<'args>
  ) -> flatbuffers::WIPOffset<Dictionary<'bldr>> {
    let mut builder = DictionaryBuilder::new(_fbb);
    if let Some(x) = args.entries { builder.add_entries(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Dictionary::VT_NAME, None)}
  }
  #[inline]
  pub fn entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Entry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Entry>>>>(Dictionary::VT_ENTRIES, None)}
  }
}

impl flatbuffers::Verifiable for Dictionary<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Entry>>>>("entries", Self::VT_ENTRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct DictionaryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub entries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Entry<'a>>>>>,
}
impl<'a> Default for DictionaryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DictionaryArgs {
      name: None,
      entries: None,
    }
  }
}

pub struct DictionaryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DictionaryBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Dictionary::VT_NAME, name);
  }
  #[inline]
  pub fn add_entries(&mut self, entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Entry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Dictionary::VT_ENTRIES, entries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DictionaryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DictionaryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Dictionary<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Dictionary<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Dictionary");
      ds.field("name", &self.name());
      ds.field("entries", &self.entries());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Dictionary`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_dictionary_unchecked`.
pub fn root_as_dictionary(buf: &[u8]) -> Result<Dictionary, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Dictionary>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Dictionary` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_dictionary_unchecked`.
pub fn size_prefixed_root_as_dictionary(buf: &[u8]) -> Result<Dictionary, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Dictionary>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Dictionary` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_dictionary_unchecked`.
pub fn root_as_dictionary_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Dictionary<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Dictionary<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Dictionary` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_dictionary_unchecked`.
pub fn size_prefixed_root_as_dictionary_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Dictionary<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Dictionary<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Dictionary and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Dictionary`.
pub unsafe fn root_as_dictionary_unchecked(buf: &[u8]) -> Dictionary {
  flatbuffers::root_unchecked::<Dictionary>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Dictionary and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Dictionary`.
pub unsafe fn size_prefixed_root_as_dictionary_unchecked(buf: &[u8]) -> Dictionary {
  flatbuffers::size_prefixed_root_unchecked::<Dictionary>(buf)
}
#[inline]
pub fn finish_dictionary_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Dictionary<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_dictionary_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Dictionary<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
